<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no,viewport-fit=cover">
        <title>第五步：自动还原魔方</title>
        <script type="text/javascript" src="./lib/three.js"></script>
        <script type="text/javascript" src="./lib/three-orbit-controls.js"></script>
        <style type="text/css">
        	body{
        		margin:0;
        		padding:0;
        	}
            div#canvas-frame {
                cursor: pointer;
                width:100%;
                height:100%;
                background-color: #EEEEEE;
            }
            .btn-list{
				list-style-type:none;
				margin:0;
				padding:0;
				position: fixed;
				top:0;
				left:0;
            }
            button{
            	font-size:20px;
            	margin:5px 0 0 5px;
            	border:1px solid #d1d1d1;
            	background-color:#fff;
            }
            p{
                color:#ff0000;
                margin: 5px 0 0 5px;
            }
        </style>
    </head>
    <body onload="threeStart();">
    	<ul class="btn-list">
    		<li><button id="autoResetV1">自动还原</button></li>
    		<li><button id="randomRotate">随机旋转</button></li>
            <li><p class="error"></p></li>
    	</ul>
        <div id="canvas-frame"></div>
        <script>
            /**
             * @param {String}  errorMessage   错误信息
             * @param {String}  scriptURI      出错的文件
             * @param {Long}    lineNumber     出错代码的行号
             * @param {Long}    columnNumber   出错代码的列号
             * @param {Object}  errorObj       错误的详细信息，Anything
             */
            window.onerror = function(errorMessage, scriptURI, lineNumber,columnNumber,errorObj) { 
                var $error = document.querySelector('#error');
                $error.innerText = errorMessage;
            }
        </script>
        <script>
            var renderer;//渲染器
            var width;//页面宽度
            var height;//页面高度
            var raycaster = new THREE.Raycaster();//光线碰撞检测器
            var mouse = new THREE.Vector2();//存储鼠标坐标或者触摸坐标
            var isRotating = false;//魔方是否正在转动
            var intersect;//碰撞光线穿过的元素
            var normalize;//触发平面法向量
            var startPoint;//触发点
            var movePoint;
            var minCubeIndex;
            var initStatus = [];//魔方初始状态
            //魔方转动的六个方向
            const XLine = new THREE.Vector3( 1, 0, 0 );//X轴正方向
            const XLineAd = new THREE.Vector3( -1, 0, 0 );//X轴负方向
            const YLine = new THREE.Vector3( 0, 1, 0 );//Y轴正方向
            const YLineAd = new THREE.Vector3( 0, -1, 0 );//Y轴负方向
            const ZLine = new THREE.Vector3( 0, 0, 1 );//Z轴正方向
            const ZLineAd = new THREE.Vector3( 0, 0, -1 );//Z轴负方向
            const CubeParams = {//魔方参数
                x:-75,
                y:75,
                z:75,
                num:3,
                len:50,
                //[右,左,上,下,前,后]
                colors:['yellow','red','blue','green','white','pink']
            };

            //随机旋转，用于打乱魔方
            function randomRotate(){
            	if(!isRotating&&!isAutoReset){
            		var stepNum = 10;
	            	var funcArr = [R,U,F,B,L,D,r,u,f,b,l,d];
	            	var stepArr = [];
	            	for(var i=0;i<stepNum;i++){
	            		var num = parseInt(Math.random()*funcArr.length);
	            		stepArr.push(funcArr[num]);
	            	}
	            	stepArr[0](0,function(){
	            		stepArr[1](0,function(){
	            			stepArr[2](0,function(){
	            				stepArr[3](0,function(){
	            					stepArr[4](0,function(){
	            						stepArr[5](0,function(){
	            							stepArr[6](0,function(){
	            								stepArr[7](0,function(){
	            									stepArr[8](0,function(){
	            										stepArr[9](0)
	            									})
	            								})
	            							})	
	            						})
	            					})
	            				})
	            			})
	            		})
	            	})
            	}
            }

            //自动还原第一版
            var isAutoReset = false;
            var currentStep = 1;
            var bottomColor;
            var topColor;
            var startTime = 0;;
            var endTime = 0;
            var stepCount = 0;
            function autoResetV1(cubes){
            	if(!checkStep8()){
                    console.log('start autoResetV1');
                    startTime = window.performance.now();
                    console.log('start at:'+startTime);
                    stepCount = 0;
	                isAutoReset = true;
					currentStep = 1;
					step1();
            	}
            }
            //第八步 顶角归位
            function step8(){
                if(checkStep8()){
                    isAutoReset = false;
                    endTime = window.performance.now();
                    console.log('end at:'+endTime);
                    console.log('end autoResetV1');
                    console.log('total times:'+(endTime-startTime));
                    console.log('total steps:'+stepCount);
                    return;
                }

                step8Case1(0);
                step8Case1(1);
                step8Case1(2);
                step8Case1(3);

                step8Case2(0);
                step8Case2(1);
                step8Case2(2);
                step8Case2(3);
            }
            //判断顶角归位 是否完成
            function checkStep8(){
                if(!checkStep7()){
                    return false;
                }
                var cube0 = getCubeByIndex(0);
                var cube1 = getCubeByIndex(1);
                var cube2 = getCubeByIndex(2);
                var ZLine1Color = getFaceColorByVector(cube1,ZLine);

                if(getFaceColorByVector(cube0,ZLine)!=ZLine1Color||
                    getFaceColorByVector(cube2,ZLine)!=ZLine1Color){
                    return false;
                }

                var cube20 = getCubeByIndex(20);
                var cube11 = getCubeByIndex(11);
                var XLine11Color = getFaceColorByVector(cube11,XLine);
                if(getFaceColorByVector(cube2,XLine)!=XLine11Color||
                    getFaceColorByVector(cube20,XLine)!=XLine11Color){
                    return false;
                }

                var cube18 = getCubeByIndex(18);
                var cube19 = getCubeByIndex(19);
                var ZLineAd19Color = getFaceColorByVector(cube19,ZLineAd);
                if(getFaceColorByVector(cube18,ZLineAd)!=ZLineAd19Color||
                    getFaceColorByVector(cube20,ZLineAd)!=ZLineAd19Color){
                    return false;
                }

                var cube9 = getCubeByIndex(9);
                var XLineAd9Color = getFaceColorByVector(cube9,XLineAd);
                if(getFaceColorByVector(cube0,XLineAd)!=XLineAd9Color||
                    getFaceColorByVector(cube18,XLineAd)!=XLineAd9Color){
                    return false;
                }

                return true;
            }
            function rotate801(rotateNum){
                //RRBBRFrBBRfR
                R(rotateNum,function(){
                    R(rotateNum,function(){
                        B(rotateNum,function(){
                            B(rotateNum,function(){
                                R(rotateNum,function(){
                                    F(rotateNum,function(){
                                        r(rotateNum,function(){
                                            B(rotateNum,function(){
                                                B(rotateNum,function(){
                                                    R(rotateNum,function(){
                                                        f(rotateNum,function(){
                                                            R(rotateNum);
                                                        })
                                                    })
                                                })
                                            })
                                        })
                                    })
                                })
                            })
                        })
                    })
                })
            }
            function rotate802(rotateNum){
                //LLBBlfLBBlFl
                L(rotateNum,function(){
                    L(rotateNum,function(){
                        B(rotateNum,function(){
                            B(rotateNum,function(){
                                l(rotateNum,function(){
                                    f(rotateNum,function(){
                                        L(rotateNum,function(){
                                            B(rotateNum,function(){
                                                B(rotateNum,function(){
                                                    l(rotateNum,function(){
                                                        F(rotateNum,function(){
                                                            l(rotateNum);
                                                        })
                                                    })
                                                })
                                            })
                                        })
                                    })
                                })
                            })
                        })
                    })
                })
            }
            //顶角归位 第一种情况
            function step8Case1(rotateNum){
                if(!isRotating){
                    var cube2 = getCubeByIndex(2,rotateNum);
                    var cube20 = getCubeByIndex(20,rotateNum);
                    var cube11 = getCubeByIndex(11,rotateNum);
                    var xLine = rotateAxisByYLine(XLine,rotateNum);
                    if(getFaceColorByVector(cube2,xLine)==getFaceColorByVector(cube20,xLine)&&
                        getFaceColorByVector(cube2,xLine)!=getFaceColorByVector(cube11,xLine)){
                        rotate801(rotateNum);
                    }
                }
            }
            //顶角归位 第二种情况
            function step8Case2(rotateNum){
                if(!isRotating){
                    var cube0 = getCubeByIndex(0,rotateNum);
                    var cube1 = getCubeByIndex(1,rotateNum);
                    var cube2 = getCubeByIndex(2,rotateNum);
                    var cube11 = getCubeByIndex(11,rotateNum);
                    var cube20 = getCubeByIndex(20,rotateNum);
                    var xLine = rotateAxisByYLine(XLine,rotateNum);
                    var zLine = rotateAxisByYLine(ZLine,rotateNum);
                    if(getFaceColorByVector(cube0,zLine)==getFaceColorByVector(cube20,xLine)&&
                        getFaceColorByVector(cube1,zLine)==getFaceColorByVector(cube2,zLine)&&
                        getFaceColorByVector(cube11,xLine)==getFaceColorByVector(cube20,xLine)&&
                        getFaceColorByVector(cube0,zLine)!=getFaceColorByVector(cube1,zLine)&&
                        getFaceColorByVector(cube20,xLine)!=getFaceColorByVector(cube20,xLine)){
                        rotate802(rotateNum);
                    }
                }
            }
            //第七步 顶棱归位
            function step7(){
            	if(checkStep7()){
                    console.log('start step8');
                    currentStep = 8;
                    step8();
                    return;
                }

                step7Case1(0);
                step7Case1(1);
                step7Case1(2);
                step7Case1(3);

                step7Case2(0);
                step7Case2(1);
                step7Case2(2);
                step7Case2(3);

                /**
                 * 1、有两个对应的面顶棱完成，另外两个对应的面顶棱没有；
                 */
                if(!isRotating&&!checkStep7()){
                    u(0);
                }
            }
            //顶棱归位 第一种情况
            function step7Case1(rotateNum){
                if(!isRotating){
                    var cube11 = getCubeByIndex(11,rotateNum);
                    var cube4 = getCubeByIndex(4,rotateNum);
                    var cube1 = getCubeByIndex(1,rotateNum);
                    var cube14 = getCubeByIndex(14,rotateNum);
                    var zLine = rotateAxisByYLine(ZLine,rotateNum);
                    var xLine = rotateAxisByYLine(XLine,rotateNum);
                    var zLine4Color = getFaceColorByVector(cube4,zLine);
                    if(getFaceColorByVector(cube1,zLine)!=zLine4Color&&
                        zLine4Color==getFaceColorByVector(cube11,xLine)&&
                        zLine4Color!=getFaceColorByVector(cube14,xLine)){
                        //FFUrLFFRlUFF
                        F(rotateNum,function(){
                            F(rotateNum,function(){
                                U(rotateNum,function(){
                                    r(rotateNum,function(){
                                        L(rotateNum,function(){
                                            F(rotateNum,function(){
                                                F(rotateNum,function(){
                                                    R(rotateNum,function(){
                                                        l(rotateNum,function(){
                                                            U(rotateNum,function(){
                                                                F(rotateNum,function(){
                                                                    F(rotateNum)
                                                                })
                                                            })
                                                        })
                                                    })
                                                })
                                            })
                                        })
                                    })
                                })
                            })
                        })
                    }
                }
            }
            //顶棱归位 第二种情况
            function step7Case2(rotateNum){
                if(!isRotating){
                    var cube1 = getCubeByIndex(1,rotateNum);
                    var cube4 = getCubeByIndex(4,rotateNum);
                    var cube11 = getCubeByIndex(11,rotateNum);
                    var cube14 = getCubeByIndex(14,rotateNum);
                    var zLine = rotateAxisByYLine(ZLine,rotateNum);
                    var xLine = rotateAxisByYLine(XLine,rotateNum);
                    var zLine1Color = getFaceColorByVector(cube1,zLine);
                    if(zLine1Color!=getFaceColorByVector(cube4,zLine)&&
                        zLine1Color==getFaceColorByVector(cube14,xLine)&&
                        zLine1Color!=getFaceColorByVector(cube11,xLine)){
                        //FFurLFFRluFF
                        F(rotateNum,function(){
                            F(rotateNum,function(){
                                u(rotateNum,function(){
                                    r(rotateNum,function(){
                                        L(rotateNum,function(){
                                            F(rotateNum,function(){
                                                F(rotateNum,function(){
                                                    R(rotateNum,function(){
                                                        l(rotateNum,function(){
                                                            u(rotateNum,function(){
                                                                F(rotateNum,function(){
                                                                    F(rotateNum)
                                                                })
                                                            })
                                                        })
                                                    })
                                                })
                                            })
                                        })
                                    })
                                })
                            })
                        })
                    }
                }
            }
            //判断是否完成第七步 顶棱归位
            function checkStep7(){
                if(!checkStep6()){
                    return false;
                }

                var cube1 = getCubeByIndex(1);
                var cube4 = getCubeByIndex(4);
                var cube11 = getCubeByIndex(11);
                var cube14 = getCubeByIndex(14);
                var cube19 = getCubeByIndex(19);
                var cube22 = getCubeByIndex(22);
                var cube9 = getCubeByIndex(9);
                var cube12 = getCubeByIndex(12);

                if(getFaceColorByVector(cube1,ZLine)!=getFaceColorByVector(cube4,ZLine)||
                    getFaceColorByVector(cube11,XLine)!=getFaceColorByVector(cube14,XLine)||
                    getFaceColorByVector(cube19,ZLineAd)!=getFaceColorByVector(cube22,ZLineAd)||
                    getFaceColorByVector(cube9,XLineAd)!=getFaceColorByVector(cube12,XLineAd)){
                    return false;
                }

                return true;
            }
            //第六步 顶角面位
            function step6(){
            	if(checkStep6()){
                    console.log('start step7');
            		currentStep = 7;
            		step7();
            		return;
            	}

            	step6Case1(0);
            	step6Case1(1);
            	step6Case1(2);
            	step6Case1(3);
            }
            function rotate601(rotateNum){
            	r(rotateNum,function(){
            		U(rotateNum,function(){
            			L(rotateNum,function(){
            				u(rotateNum,function(){
            					R(rotateNum,function(){
            						U(rotateNum,function(){
            							l(rotateNum,function(){
            								u(rotateNum)
            							})
            						})
            					})
            				})
            			})
            		})
            	})
            }
            function rotate602(rotateNum){
            	U(rotateNum,function(){
            		L(rotateNum,function(){
            			u(rotateNum,function(){
            				r(rotateNum,function(){
            					U(rotateNum,function(){
            						l(rotateNum,function(){
            							u(rotateNum,function(){
            								R(rotateNum)
            							})
            						})
            					})
            				})
            			})
            		})
            	})
            }
            function rotate603(rotateNum){
            	R(rotateNum,function(){
            		U(rotateNum,function(){
            			r(rotateNum,function(){
            				U(rotateNum,function(){
            					R(rotateNum,function(){
            						U(rotateNum,function(){
            							U(rotateNum,function(){
            								r(rotateNum)
            							})
            						})
            					})
            				})
            			})
            		})
            	})
            }
            //顶角面位 第一种、第二种和第三种情况
            function step6Case1(rotateNum){
            	if(!isRotating){
            		var cube0 = getCubeByIndex(0,rotateNum);
            		var cube2 = getCubeByIndex(2,rotateNum);
            		var cube20 = getCubeByIndex(20,rotateNum);
            		var zLine = rotateAxisByYLine(ZLine,rotateNum);
            		var xLine = rotateAxisByYLine(XLine,rotateNum);
            		if(getFaceColorByVector(cube0,zLine)==topColor&&
            			getFaceColorByVector(cube2,xLine)==topColor){
            			rotate601(rotateNum);
            		}else if(getFaceColorByVector(cube2,zLine)==topColor&&
            			getFaceColorByVector(cube20,xLine)==topColor){
            			rotate602(rotateNum);
            		}else if(getFaceColorByVector(cube0,zLine)==topColor){
            			rotate603(rotateNum);
            		}
            	}
            }
            //判断是否完成第六步 顶角面位
            function checkStep6(){
            	if(!checkStep5()){
            		return false;
            	}

            	var cube0 = getCubeByIndex(0);
            	var cube2 = getCubeByIndex(2);
            	var cube18 = getCubeByIndex(18);
            	var cube20 = getCubeByIndex(20);
            	if(getFaceColorByVector(cube0,YLine)!=topColor||
            		getFaceColorByVector(cube2,YLine)!=topColor||
            		getFaceColorByVector(cube18,YLine)!=topColor||
            		getFaceColorByVector(cube20,YLine)!=topColor){
            		return false;
            	}
            	return true;
            }
            //第五步 顶棱面位
            function step5(){
            	if(checkStep5()){
                    console.log('start step6');
            		currentStep = 6;
            		step6();
            		return;
            	}

            	step5Case1(0);
            	step5Case1(1);
            	step5Case1(2);
            	step5Case1(3);

            	step5Case2(0);
            	step5Case2(1);
            	step5Case2(2);
            	step5Case2(3);

            	step5Case3(0);
            	step5Case3(1);
            	step5Case3(2);
            	step5Case3(3);
            }
            function rotate501(rotateNum,next){
            	r(rotateNum,function(){
            		u(rotateNum,function(){
            			f(rotateNum,function(){
            				U(rotateNum,function(){
            					F(rotateNum,function(){
            						if(next){
            							R(rotateNum,next);
            						}else{
            							R(rotateNum);
            						}
            					})
            				})
            			})
            		})
            	})
            }
            function rotate502(rotateNum,next){
            	r(rotateNum,function(){
            		f(rotateNum,function(){
            			u(rotateNum,function(){
            				F(rotateNum,function(){
            					U(rotateNum,function(){
            						if(next){
            							R(rotateNum,next);
            						}else{
            							R(rotateNum);
            						}
            					})
            				})
            			})
            		})
            	})
            }
            //顶棱面位 第一种情况
            function step5Case1(rotateNum){
            	if(!isRotating){
            		var cube1 = getCubeByIndex(1,rotateNum);
	            	var cube11 = getCubeByIndex(11,rotateNum);
	            	var cube9 = getCubeByIndex(9,rotateNum);
	            	var cube19 = getCubeByIndex(19,rotateNum);
	            	var cube10 = getCubeByIndex(10,rotateNum);
	            	var yLine = rotateAxisByYLine(YLine,rotateNum);
	            	var zLine = rotateAxisByYLine(ZLine,rotateNum);
	            	var xLine = rotateAxisByYLine(XLine,rotateNum);
	            	if(getFaceColorByVector(cube10,yLine)==topColor&&
	            		getFaceColorByVector(cube9,yLine)==topColor&&
	            		getFaceColorByVector(cube19,yLine)==topColor&&
	            		getFaceColorByVector(cube1,zLine)==topColor&&
	            		getFaceColorByVector(cube11,xLine)==topColor){
	            		rotate501(rotateNum);
	            	}
            	}
            }
            //顶棱面位 第二种情况
            function step5Case2(rotateNum){
            	if(!isRotating){
            		var cube1 = getCubeByIndex(1,rotateNum);
	            	var cube11 = getCubeByIndex(11,rotateNum);
	            	var cube19 = getCubeByIndex(19,rotateNum);
	            	var cube10 = getCubeByIndex(10,rotateNum);
	            	var yLine = rotateAxisByYLine(YLine,rotateNum);
	            	var xLine = rotateAxisByYLine(XLine,rotateNum);
	            	if(getFaceColorByVector(cube10,yLine)==topColor&&
	            		getFaceColorByVector(cube1,yLine)==topColor&&
	            		getFaceColorByVector(cube19,yLine)==topColor&&
	            		getFaceColorByVector(cube11,xLine)==topColor){
	            		rotate501(rotateNum);
	            	}
            	}
            }
            //顶棱面位 第三种情况
            function step5Case3(rotateNum){
            	if(!isRotating){
            		var cube1 = getCubeByIndex(1,rotateNum);
	            	var cube11 = getCubeByIndex(11,rotateNum);
	            	var cube10 = getCubeByIndex(10,rotateNum);
	            	var yLine = rotateAxisByYLine(YLine,rotateNum);
	            	var zLine = rotateAxisByYLine(ZLine,rotateNum);
	            	var xLine = rotateAxisByYLine(XLine,rotateNum);
	            	if(getFaceColorByVector(cube10,yLine)==topColor&&
	            		getFaceColorByVector(cube1,zLine)==topColor&&
	            		getFaceColorByVector(cube11,xLine)==topColor){
	            		rotate501(rotateNum,function(){
	            			U(rotateNum,function(){
	            				rotate502(rotateNum);
	            			})
	            		});
	            	}
            	}
            }
            //判断是否完成第五步 顶棱面位
            function checkStep5(){
            	if(!checkStep4()){
            		return false;
            	}

            	var cube1 = getCubeByIndex(1);
            	var cube11 = getCubeByIndex(11);
            	var cube9 = getCubeByIndex(9);
            	var cube19 = getCubeByIndex(19);
            	var cube10 = getCubeByIndex(10);
            	if(getFaceColorByVector(cube10,YLine)!=topColor||
            		getFaceColorByVector(cube1,YLine)!=topColor||
            		getFaceColorByVector(cube11,YLine)!=topColor||
            		getFaceColorByVector(cube9,YLine)!=topColor||
            		getFaceColorByVector(cube19,YLine)!=topColor){
            		return false;
            	}

            	return true;
            }
            //第四步 中棱归位
            function step4(){
            	if(checkStep4()){
                    console.log('start step5');
            		currentStep = 5;
            		step5();
            		return;
            	}

            	step4Case1And2(0);
            	step4Case1And2(1);
            	step4Case1And2(2);
            	step4Case1And2(3);

            	step4Case3(0);
            	step4Case3(1);
            	step4Case3(2);
            	step4Case3(3);

                step4Case4(0);
                step4Case4(1);
                step4Case4(2);
                step4Case4(3);

                step4Case5(0);
                step4Case5(1);
                step4Case5(2);
                step4Case5(3);

                if(!isRotating){
                    isAutoReset = false;
                }
            }
            function rotate401(rotateNum,next){
                u(rotateNum,function(){
                    f(rotateNum,function(){
                        U(rotateNum,function(){
                            F(rotateNum,function(){
                                U(rotateNum,function(){
                                    R(rotateNum,function(){
                                        u(rotateNum,function(){
                                            if(next){
                                                r(rotateNum,next);
                                            }else{
                                                r(rotateNum);
                                            }
                                        })
                                    })
                                })
                            })
                        })
                    })
                })
            }
            function rotate402(rotateNum,next){
            	U(rotateNum,function(){
                    R(rotateNum,function(){
                        u(rotateNum,function(){
                            r(rotateNum,function(){
                                u(rotateNum,function(){
                                    f(rotateNum,function(){
                                        U(rotateNum,function(){
                                            if(next){
                                                F(rotateNum,next);
                                            }else{
                                                F(rotateNum);
                                            }
                                        })
                                    })
                                })
                            })
                        })
                    })
                })
            }
            //中棱归位第一种情况和第二种情况
            function step4Case1And2(rotateNum){
            	if(!isRotating){
            		var cube11 = getCubeByIndex(11,rotateNum);
            		var cube14 = getCubeByIndex(14,rotateNum);
            		var cube4 = getCubeByIndex(4,rotateNum);
                    var cube22 = getCubeByIndex(22,rotateNum);
                    var cube23 = getCubeByIndex(23,rotateNum);
                    var cube5 = getCubeByIndex(5,rotateNum);
            		var yLine = rotateAxisByYLine(YLine,rotateNum);
            		var xLine = rotateAxisByYLine(XLine,rotateNum);
            		var zLine = rotateAxisByYLine(ZLine,rotateNum);
                    var zLineAd = rotateAxisByYLine(ZLineAd,rotateNum);
            		var yLine11Color = getFaceColorByVector(cube11,yLine);
            		var xLine11Color = getFaceColorByVector(cube11,xLine);

                    if(yLine11Color!=topColor&&
                        xLine11Color!=topColor){
                        if(yLine11Color==getFaceColorByVector(cube4,zLine)&&
                            xLine11Color==getFaceColorByVector(cube14,xLine)&&
                            (getFaceColorByVector(cube5,zLine)!=yLine11Color||
                            getFaceColorByVector(cube5,xLine)!=xLine11Color)){
                            rotate401(rotateNum);
                        }else if(yLine11Color==getFaceColorByVector(cube22,zLineAd)&&
                            xLine11Color==getFaceColorByVector(cube14,xLine)&&
                            (getFaceColorByVector(cube23,zLineAd)!=yLine11Color||
                            getFaceColorByVector(cube23,xLine)!=xLine11Color)){
                            rotateNum++;
                            if(rotateNum>=4){
                                rotateNum = 0;
                            }
                            rotate402(rotateNum);
                        }else{
                            u(rotateNum,function(){
                                rotateNum++;
                                if(rotateNum>=4){
                                    rotateNum = 0;
                                }
                                step4Case1And2(rotateNum);
                            })
                        }
                    }
            	}
            }
            //中棱归位第三种情况
            function step4Case3(rotateNum){
            	if(!isRotating){
            		var cube4 = getCubeByIndex(4,rotateNum);
            		var cube5 = getCubeByIndex(5,rotateNum);
            		var cube14 = getCubeByIndex(14,rotateNum);
            		var xLine = rotateAxisByYLine(XLine,rotateNum);
            		var zLine = rotateAxisByYLine(ZLine,rotateNum);
                    if(getFaceColorByVector(cube4,zLine)==getFaceColorByVector(cube5,xLine)&&
                        getFaceColorByVector(cube5,zLine)==getFaceColorByVector(cube14,xLine)){
                        rotate401(rotateNum,function(){
                            U(rotateNum,function(){
                                U(rotateNum,function(){
                                    rotate401(rotateNum);
                                })
                            })
                        })
            		}
            	}
            }
            //中棱归位第四种情况
            function step4Case4(rotateNum){
                if(!isRotating){
                    var cube1 = getCubeByIndex(1,rotateNum);
                    var cube3 = getCubeByIndex(3,rotateNum);
                    var cube4 = getCubeByIndex(4,rotateNum);
                    var cube5 = getCubeByIndex(5,rotateNum);
                    var cube14 = getCubeByIndex(14,rotateNum);
                    var cube11 = getCubeByIndex(11,rotateNum);
                    var zLine = rotateAxisByYLine(ZLine,rotateNum);
                    var xLine = rotateAxisByYLine(XLine,rotateNum);
                    var yLine = rotateAxisByYLine(YLine,rotateNum);
                    var zLine4Color = getFaceColorByVector(cube4,zLine);

                    if(getFaceColorByVector(cube3,zLine)==zLine4Color&&getFaceColorByVector(cube5,zLine)!=zLine4Color){
                        if(getFaceColorByVector(cube1,zLine)==zLine4Color){
                            console.log('step4Case4-1');
                            rotate402(rotateNum);
                        }else if(getFaceColorByVector(cube11,yLine)==zLine4Color){
                            console.log('step4Case4-2');
                            rotate401(rotateNum);
                        }else{
                            console.log('step4Case4-3');
                            u(rotateNum)
                        }
                    }
                }
            }
            //中棱归位第五种情况
            function step4Case5(rotateNum){
                if(!isRotating){
                    var cube5 = getCubeByIndex(5,rotateNum);
                    var cube14 = getCubeByIndex(14,rotateNum);
                    var cube23 = getCubeByIndex(23,rotateNum);
                    var cube1 = getCubeByIndex(1,rotateNum);
                    var cube11 = getCubeByIndex(11,rotateNum);
                    var cube4 = getCubeByIndex(4,rotateNum);
                    var xLine = rotateAxisByYLine(XLine,rotateNum);
                    var zLine = rotateAxisByYLine(ZLine,rotateNum);
                    var yLine = rotateAxisByYLine(YLine,rotateNum);
                    var xLine14Color = getFaceColorByVector(cube14,xLine);

                    if(xLine14Color==getFaceColorByVector(cube23,xLine)&&xLine14Color!=getFaceColorByVector(cube5,xLine)){
                        if(getFaceColorByVector(cube1,yLine)==xLine14Color){
                            console.log('step4Case5-1');
                            rotate402(rotateNum);
                        }else if(getFaceColorByVector(cube11,xLine)==xLine14Color){
                            console.log('step4Case5-2');
                            rotate401(rotateNum);
                        }else{
                            console.log('step4Case5-3');
                            u(rotateNum)
                        }
                    }
                }
            }
            //判断是否完成第四步 中棱归位
            function checkStep4(){
            	if(!checkStep3()){
            		return false;
            	}

                var cube3 = getCubeByIndex(3);
                var cube4 = getCubeByIndex(4);
                var cube5 = getCubeByIndex(5);
                var zLine3Color = getFaceColorByVector(cube3,ZLine);
                if(getFaceColorByVector(cube4,ZLine)!=zLine3Color||
                    getFaceColorByVector(cube5,ZLine)!=zLine3Color){
                    return false;
                }

                var cube14 = getCubeByIndex(14);
                var cube23 = getCubeByIndex(23);
                var xLine5Color = getFaceColorByVector(cube5,XLine);
                if(getFaceColorByVector(cube14,XLine)!=xLine5Color||
                    getFaceColorByVector(cube23,XLine)!=xLine5Color){
                    return false;
                }

                var cube21 = getCubeByIndex(21);
                var cube22 = getCubeByIndex(22);
                var zLineAd23Color = getFaceColorByVector(cube23,ZLineAd);
                if(getFaceColorByVector(cube21,ZLineAd)!=zLineAd23Color||
                    getFaceColorByVector(cube22,ZLineAd)!=zLineAd23Color){
                    return false;
                }

                var cube12 = getCubeByIndex(12);
                var xLineAd3Color = getFaceColorByVector(cube3,XLineAd);
                if(getFaceColorByVector(cube12,XLineAd)!=xLineAd3Color||
                    getFaceColorByVector(cube21,XLineAd)!=xLineAd3Color){
                    return false;
                }

            	return true;
            }
            //第三步底角归位
            function step3(){
            	if(checkStep3()){
                    console.log('start step4');
                    currentStep = 4;
                    step4();
            		return;
            	}
                step3Case1(0);
                step3Case1(1);
                step3Case1(2);
                step3Case1(3);

                step3Case2(0);
                step3Case2(1);
                step3Case2(2);
                step3Case2(3);

                step3Case3(0);
                step3Case3(1);
                step3Case3(2);
                step3Case3(3);

            	step3Case4(0);
                step3Case4(1);
                step3Case4(2);
                step3Case4(3);

                step3Case5(0);
                step3Case5(1);
                step3Case5(2);
                step3Case5(3);
            }
            //底角归位第一种情况
            function step3Case1(rotateNum,startNum){
            	if(!isRotating){
            		var cube2 = getCubeByIndex(2,rotateNum);
	            	var cube4 = getCubeByIndex(4,rotateNum);
	            	var cube7 = getCubeByIndex(7,rotateNum);
	            	var cube14 = getCubeByIndex(14,rotateNum);
	            	var cube17 = getCubeByIndex(17,rotateNum);
                    var cube8 = getCubeByIndex(8,rotateNum);
	            	var xLine = rotateAxisByYLine(XLine,rotateNum);
	            	var zLine = rotateAxisByYLine(ZLine,rotateNum);
	            	var yLine = rotateAxisByYLine(YLine,rotateNum);
	            	var zLineAd = rotateAxisByYLine(ZLineAd,rotateNum);
	            	var xLineAd = rotateAxisByYLine(XLineAd,rotateNum);
	            	var yLineAd = rotateAxisByYLine(YLineAd,rotateNum);
	            	var zLine2Color = getFaceColorByVector(cube2,zLine);
	            	var yLine2Color = getFaceColorByVector(cube2,yLine);

                    if(getFaceColorByVector(cube2,xLine)==bottomColor&&!cube2.skipNext){
                        if(getFaceColorByVector(cube8,yLineAd)!=bottomColor&&
                            getFaceColorByVector(cube4,zLine)==zLine2Color&&
                            getFaceColorByVector(cube7,zLine)==zLine2Color&& 
                            getFaceColorByVector(cube14,xLine)==yLine2Color&&
                            getFaceColorByVector(cube17,xLine)==yLine2Color){
                            R(rotateNum,function(){
                                U(rotateNum,function(){
                                    r(rotateNum)
                                })
                            })
                        }else{
                            u(rotateNum,function(){
                                rotateNum++;
                                if(rotateNum>=4){
                                    rotateNum = 0;
                                }
                                if(startNum!=rotateNum){//防止重复检测造成无限循环
                                    if(startNum==null||startNum==undefined){
                                        startNum = rotateNum-1;
                                        step3Case1(rotateNum,startNum);
                                    }else{
                                        step3Case1(rotateNum,startNum);
                                    }
                                }else{
                                    var cube2 = getCubeByIndex(2,rotateNum);
                                    cube2.skipNext = true;//下一次不进入判断
                                    step3();
                                }
                            })
                        }
                    }
            	}
            }
            //底角归位第二种情况
            function step3Case2(rotateNum,startNum){
            	if(!isRotating){
            		var xLine = rotateAxisByYLine(XLine,rotateNum);
	            	var zLine = rotateAxisByYLine(ZLine,rotateNum);
	            	var yLine = rotateAxisByYLine(YLine,rotateNum);
	            	var zLineAd = rotateAxisByYLine(ZLineAd,rotateNum);
	            	var xLineAd = rotateAxisByYLine(XLineAd,rotateNum);
	            	var yLineAd = rotateAxisByYLine(YLineAd,rotateNum);
	            	var cube2 = getCubeByIndex(2,rotateNum);
	            	var cube4 = getCubeByIndex(4,rotateNum);
	            	var cube7 = getCubeByIndex(7,rotateNum);
	            	var cube14 = getCubeByIndex(14,rotateNum);
	            	var cube17 = getCubeByIndex(17,rotateNum);
                    var cube8 = getCubeByIndex(8,rotateNum);
	            	var yLine2Color = getFaceColorByVector(cube2,yLine);
	            	var xLine2Color = getFaceColorByVector(cube2,xLine);

                    if(getFaceColorByVector(cube2,zLine)==bottomColor&&!cube2.skipNext){
                        if(getFaceColorByVector(cube8,yLineAd)!=bottomColor&&
                            getFaceColorByVector(cube4,zLine)==yLine2Color&&
                            getFaceColorByVector(cube7,zLine)==yLine2Color&&
                            getFaceColorByVector(cube14,xLine)==xLine2Color&&
                            getFaceColorByVector(cube17,xLine)==xLine2Color){
                            f(rotateNum,function(){
                                u(rotateNum,function(){
                                    F(rotateNum)
                                })
                            })
                        }else{
                            u(rotateNum,function(){
                                rotateNum++;
                                if(rotateNum>=4){
                                    rotateNum = 0;
                                }
                                if(startNum!=rotateNum){//防止重复检测造成无限循环
                                    if(startNum==null||startNum==undefined){
                                        startNum = rotateNum-1;
                                        step3Case2(rotateNum,startNum);
                                    }else{
                                        step3Case2(rotateNum,startNum);
                                    }
                                }else{
                                    var cube2 = getCubeByIndex(2,rotateNum);
                                    cube2.skipNext = true;//下一次不进入判断
                                    step3();
                                }
                            })
                        }
                    }
            	}
            }
            //底角归位第三种情况
            function step3Case3(rotateNum,startNum){
            	if(!isRotating){
            		var xLine = rotateAxisByYLine(XLine,rotateNum);
	            	var zLine = rotateAxisByYLine(ZLine,rotateNum);
	            	var yLine = rotateAxisByYLine(YLine,rotateNum);
	            	var zLineAd = rotateAxisByYLine(ZLineAd,rotateNum);
	            	var xLineAd = rotateAxisByYLine(XLineAd,rotateNum);
	            	var yLineAd = rotateAxisByYLine(YLineAd,rotateNum);
            		var cube2 = getCubeByIndex(2,rotateNum);
            		var cube14 = getCubeByIndex(14,rotateNum);
            		var cube4 = getCubeByIndex(4,rotateNum);
            		var cube7 = getCubeByIndex(7,rotateNum);
                    var cube8 = getCubeByIndex(8,rotateNum);
            		var cube17 = getCubeByIndex(17,rotateNum);
            		var zLine2Color = getFaceColorByVector(cube2,zLine);
            		var xLine2Color = getFaceColorByVector(cube2,xLine);

            		if(getFaceColorByVector(cube2,yLine)==bottomColor&&!cube2.skipNext){
            			if(getFaceColorByVector(cube8,yLineAd)!=bottomColor&&
                            getFaceColorByVector(cube14,xLine)==zLine2Color&&
            			    getFaceColorByVector(cube17,xLine)==zLine2Color&&
            			    getFaceColorByVector(cube4,zLine)==xLine2Color&&
            			    getFaceColorByVector(cube7,zLine)==xLine2Color){
                            //转换为第二种情况
            			   	f(rotateNum,function(){
            			   		u(rotateNum,function(){
            			   			u(rotateNum,function(){
            			   				F(rotateNum,function(){
            			   					U(rotateNum)
            			   				})
            			   			})
            			   		})
            			   	})
            			}else{
        					u(rotateNum,function(){
                                rotateNum++;
                                if(rotateNum>=4){
                                    rotateNum = 0;
                                }
                                if(startNum!=rotateNum){//防止重复检测造成无限循环
                                    if(startNum==null||startNum==undefined){
                                        startNum = rotateNum-1;
                                        step3Case3(rotateNum,startNum);
                                    }else{
                                        step3Case3(rotateNum,startNum);
                                    }
                                }else{
                                    var cube2 = getCubeByIndex(2,rotateNum);
                                    cube2.skipNext = true;//下一次不进入判断
                                    step3();
                                }
                            })
            			}
            		}
            	}
            }
            //底角归位第四种情况
            function step3Case4(rotateNum){
            	if(!isRotating){
            		var cube8 = getCubeByIndex(8,rotateNum);
	            	var cube17 = getCubeByIndex(17,rotateNum);
	            	var cube14 = getCubeByIndex(14,rotateNum);
                    var cube4 = getCubeByIndex(4,rotateNum);
                    var cube7 = getCubeByIndex(7,rotateNum);
	            	var xLine = rotateAxisByYLine(XLine,rotateNum);
	            	var zLine = rotateAxisByYLine(ZLine,rotateNum);
                    var yLineAd = rotateAxisByYLine(YLineAd,rotateNum);
	            	var zLine8Color = getFaceColorByVector(cube8,zLine);
                    var yLineAd8Color = getFaceColorByVector(cube8,yLineAd);

                    if(getFaceColorByVector(cube8,xLine)==bottomColor){
                    	if(getFaceColorByVector(cube17,xLine)==zLine8Color&&
                        	getFaceColorByVector(cube14,xLine)==zLine8Color&&
                        	getFaceColorByVector(cube4,zLine)==yLineAd8Color&&
                        	getFaceColorByVector(cube7,zLine)==yLineAd8Color){
	                        //转换为第一种情况
	                        f(rotateNum,function(){
	                            U(rotateNum,function(){
	                                F(rotateNum)
	                            })
	                        })
                    	}else{
                    		//转换为第三种情况
                    		f(rotateNum,function(){
                    			u(rotateNum,function(){
                    				F(rotateNum)
                    			})
                    		})
                    	}
                    }
            	}
            }
            //底角归位第五种情况
            function step3Case5(rotateNum){
            	if(!isRotating){
            		var cube8 = getCubeByIndex(8,rotateNum);
	            	var cube4 = getCubeByIndex(4,rotateNum);
	            	var cube7 = getCubeByIndex(7,rotateNum);
                    var cube14 = getCubeByIndex(14,rotateNum);
                    var cube17 = getCubeByIndex(17,rotateNum);
	            	var xLine = rotateAxisByYLine(XLine,rotateNum);
	            	var zLine = rotateAxisByYLine(ZLine,rotateNum);
                    var yLineAd = rotateAxisByYLine(YLineAd,rotateNum);
            		var xLine8Color = getFaceColorByVector(cube8,xLine);
                    var yLineAd8Color = getFaceColorByVector(cube8,yLineAd);

                    if(getFaceColorByVector(cube8,zLine)==bottomColor){
                    	if(getFaceColorByVector(cube7,zLine)==xLine8Color&&
                        	getFaceColorByVector(cube4,zLine)==xLine8Color&&
                        	getFaceColorByVector(cube14,xLine)==yLineAd8Color&&
                        	getFaceColorByVector(cube17,xLine)==yLineAd8Color){
	                        //转换为第二种情况
	                        f(rotateNum,function(){
	                            u(rotateNum,function(){
	                                F(rotateNum,function(){
	                                    U(rotateNum)
	                                })
	                            })
	                        })
                    	}else{
                    		//转换为第三种情况
                    		R(rotateNum,function(){
                    			u(rotateNum,function(){
                    				r(rotateNum)
                    			})
                    		})
                    	}
                    }
                }
            }

            //判断是否完成第三步底角归位
            function checkStep3(){
            	if(!checkStep2(false)){
            		return false;
            	}

            	var cube6 = getCubeByIndex(6);
            	var cube7 = getCubeByIndex(7);
            	var cube8 = getCubeByIndex(8);
            	var zColor = getFaceColorByVector(cube6,ZLine);
            	if(getFaceColorByVector(cube7,ZLine)!=zColor||
            	   getFaceColorByVector(cube8,ZLine)!=zColor){
            		return false;
            	}

            	var cube17 = getCubeByIndex(17);
            	var cube26 = getCubeByIndex(26);
            	var xColor = getFaceColorByVector(cube17,XLine);
            	if(getFaceColorByVector(cube8,XLine)!=xColor||
            	   getFaceColorByVector(cube26,XLine)!=xColor){
            		return false;
            	}

            	var cube24 = getCubeByIndex(24);
            	var cube25 = getCubeByIndex(25);
            	var cube26 = getCubeByIndex(26); 
            	var zAdColor = getFaceColorByVector(cube24,ZLineAd);
            	if(getFaceColorByVector(cube25,ZLineAd)!=zAdColor||
            	   getFaceColorByVector(cube26,ZLineAd)!=zAdColor){
            		return false;
            	}

            	var cube15 = getCubeByIndex(15);
            	var cube24 = getCubeByIndex(24);
            	var xAdColor = getFaceColorByVector(cube15,XLineAd);
            	if(getFaceColorByVector(cube6,XLineAd)!=xAdColor||
            	   getFaceColorByVector(cube24,XLineAd)!=xAdColor){
            		return false;
            	}

            	return true;
            }
            //第二步底棱归位
            function step2(){
            	if(checkStep2(true)){
                    console.log('start step3');
                    currentStep = 3;
                    step3();
					return;
            	}

            	step2Case1(0);
            	step2Case1(1);
            	step2Case1(2);
            	step2Case1(3);

            	step2Case2(0);
            	step2Case2(1);
            	step2Case2(2);
            	step2Case2(3);

            	step2Case3(0);
            	step2Case3(1);
            	step2Case3(2);
            	step2Case3(3);
            }
            //底棱归位第一种情况
            function step2Case1(rotateNum){
            	if(!isRotating){
            		var cube1 = getCubeByIndex(1,rotateNum);
            		var cube4 = getCubeByIndex(4,rotateNum);
            		var yLine = rotateAxisByYLine(YLine,rotateNum);
            		var zLine = rotateAxisByYLine(ZLine,rotateNum);

            		if(getFaceColorByVector(cube1,yLine)==bottomColor){
	            		if(getFaceColorByVector(cube1,zLine)==getFaceColorByVector(cube4,zLine)){
                            F(rotateNum,function(){
                                F(rotateNum);
                            });
	            		}else{
	            			u(rotateNum,function(){
                                rotateNum++;
                                if(rotateNum>=4){
                                    rotateNum = 0;
                                }
                                step2Case1(rotateNum);
	            			});
	            		}
	            	}
            	}
            }
            //底棱归位第二种情况
            function step2Case2(rotateNum){
                if(!isRotating){
                	var cube7 = getCubeByIndex(7,rotateNum);
                	var cube8 = getCubeByIndex(8,rotateNum);
                    var cube2 = getCubeByIndex(2,rotateNum);
                	var yLineAd = rotateAxisByYLine(YLineAd,rotateNum);
                    var xLine = rotateAxisByYLine(XLine,rotateNum);
                	if(getFaceColorByVector(cube7,yLineAd)==bottomColor&&
                		getFaceColorByVector(cube8,yLineAd)==bottomColor){
                        if(getCubeByIndex(cube2,xLine)!=bottomColor){
                            R(rotateNum,function(){
                                u(rotateNum,function(){
                                    r(rotateNum);
                                });
                            })
                        }else{
                            f(rotateNum,function(){
                                u(rotateNum,function(){
                                    F(rotateNum);
                                });
                            })
                        }
                	}
                }
            }
            //底棱归位第三种情况
            function step2Case3(rotateNum){
                if(!isRotating){
                	var cube7 = getCubeByIndex(7,rotateNum);
                	var cube6 = getCubeByIndex(6,rotateNum);
                    var cube0 = getCubeByIndex(0,rotateNum);
                	var yLineAd = rotateAxisByYLine(YLineAd,rotateNum);
                    var xLineAd = rotateAxisByYLine(XLineAd,rotateNum);
                	if(getFaceColorByVector(cube7,yLineAd)==bottomColor&&
                		getFaceColorByVector(cube6,yLineAd)==bottomColor){
                        if(getFaceColorByVector(cube0,xLineAd)!=bottomColor){
                            l(rotateNum,function(){
                                u(rotateNum,function(){
                                    L(rotateNum)
                                });
                            })
                        }else{
                            f(rotateNum,function(){
                                u(rotateNum,function(){
                                    F(rotateNum);
                                });
                            })
                        }
                	}
                }
            }
            /**
             * 判断是否完成第二部底棱归位
             * isStrict为true表示严格底十字模式
             */
            function checkStep2(isStrict){
            	var cube4 = getCubeByIndex(4);
            	var cube7 = getCubeByIndex(7);
            	var zLine4Color = getFaceColorByVector(cube4,ZLine);
            	var zLine7Color = getFaceColorByVector(cube7,ZLine);
            	if(zLine4Color!=zLine7Color||
            		zLine4Color==topColor||
            		zLine4Color==bottomColor||
            		zLine7Color==topColor||
            		zLine7Color==bottomColor){
            		return false;
            	}

            	var cube14 = getCubeByIndex(14);
            	var cube17 = getCubeByIndex(17);
            	var xLine14Color = getFaceColorByVector(cube14,XLine);
            	var xLine17Color = getFaceColorByVector(cube17,XLine);
            	if(xLine14Color!=xLine17Color||
            		xLine17Color==topColor||
            		xLine17Color==bottomColor||
            		xLine14Color==topColor||
            		xLine14Color==bottomColor){
            		return false;
            	}

            	var cube22 = getCubeByIndex(22);
            	var cube25 = getCubeByIndex(25);
            	var zLineAd22Color = getFaceColorByVector(cube22,ZLineAd);
            	var zLineAd25Color = getFaceColorByVector(cube25,ZLineAd);
            	if(zLineAd22Color!=zLineAd25Color||
            		zLineAd25Color==topColor||
            		zLineAd25Color==bottomColor||
            		zLineAd22Color==topColor||
            		zLineAd22Color==bottomColor){
            		return false;
            	}

            	var cube12 = getCubeByIndex(12);
            	var cube15 = getCubeByIndex(15);
            	var xLineAd12Color = getFaceColorByVector(cube12,XLineAd);
            	var xLineAd15Color = getFaceColorByVector(cube15,XLineAd);
            	if(xLineAd12Color!=xLineAd15Color||
            		xLineAd15Color==topColor||
            		xLineAd15Color==bottomColor||
            		xLineAd12Color==topColor||
            		xLineAd12Color==bottomColor){
            		return false;
            	}

            	//强制底十字
            	if(getFaceColorByVector(cube7,YLineAd)!=bottomColor||
            		getFaceColorByVector(cube17,YLineAd)!=bottomColor||
            		getFaceColorByVector(cube25,YLineAd)!=bottomColor||
            		getFaceColorByVector(cube15,YLineAd)!=bottomColor){
            		return false;
            	}
            	if(isStrict){
                    var cube6 = getCubeByIndex(6);
                    var cube8 = getCubeByIndex(8);
                    var cube26 = getCubeByIndex(26);
                    var cube24 = getCubeByIndex(24);
                    var YLineAd6Color = getFaceColorByVector(cube6,YLineAd);
                    var YLineAd8Color = getFaceColorByVector(cube8,YLineAd);
                    var YLineAd26Color = getFaceColorByVector(cube26,YLineAd);
                    var YLineAd24Color = getFaceColorByVector(cube24,YLineAd);

                    //不能为底色
            		if(YLineAd6Color==bottomColor||
	                    YLineAd8Color==bottomColor||
	                    YLineAd26Color==bottomColor||
	                    YLineAd24Color==bottomColor){
	                    return false;
	                }
            	}

            	return true;
            }
            //第一步小白花
            function step1(){
            	/**
            	 * 找到初始化时上表面颜色在中心的面，调整魔方让该表面依然为上表面；
            	 * 然后对照初始化时下表面颜色的位置，按既定规律转动魔方；
            	 * 直接找当前上表面中心面的颜色和其对应的下表面颜色，省去旋转调整的过程。
            	 */
            	var topCenter = getCubeByIndex(10);
				topColor = getFaceColorByVector(topCenter,YLine);//获取上表面颜色
				bottomColor = getOppositeColor(topColor);

            	if(checkStep1(bottomColor)){
                    console.log('start step2');
					currentStep = 2;
					step2();
					return;
				}
				
				step1Case1(0);
				step1Case1(1);
				step1Case1(2);
				step1Case1(3);

				step1Case2(0);
				step1Case2(1);
				step1Case2(2);
				step1Case2(3);

				step1Case3(0);
				step1Case3(1);
				step1Case3(2);
				step1Case3(3);
				
				step1Case4(0);
				step1Case4(1);
				step1Case4(2);
				step1Case4(3);				
            }
            //判断是否完成第一步小白花
            function checkStep1(){
            	var indexs = [1,9,11,19];
            	var step1 = true;
            	for(var i=0;i<indexs.length;i++){
            		var item = getCubeByIndex(indexs[i]);
            		var color = getFaceColorByVector(item,YLine);//获取上表面颜色
            		if(color!=bottomColor){
            			step1 = false;
            			break;
            		}
            	}
            	return step1;
            }
            //小白花第一种情况
            function step1Case1(rotateNum){
            	if(!isRotating){
            		var cube3 = getCubeByIndex(3,rotateNum);
	        		var cube9 = getCubeByIndex(9,rotateNum);
	        		var zLine = rotateAxisByYLine(ZLine,rotateNum);
	        		var yLine = rotateAxisByYLine(YLine,rotateNum);
	        		var xLineAd = rotateAxisByYLine(XLineAd,rotateNum);

	            	if(getFaceColorByVector(cube3,zLine)==bottomColor){//101、107
						if(getFaceColorByVector(cube9,yLine)!=bottomColor){
							l(rotateNum);
						}else{
							u(rotateNum);
						}
					}
            	}
            }
            //小白花第二种情况
            function step1Case2(rotateNum){
            	if(!isRotating){
            		var cube5 = getCubeByIndex(5,rotateNum);
            		var cube11 = getCubeByIndex(11,rotateNum);
            		var zLine = rotateAxisByYLine(ZLine,rotateNum);
            		var yLine = rotateAxisByYLine(YLine,rotateNum);
            		var xLine = rotateAxisByYLine(XLine,rotateNum);

            		if(getFaceColorByVector(cube5,zLine)==bottomColor){
						if(getFaceColorByVector(cube11,yLine)!=bottomColor){
							R(rotateNum);
						}else{
							u(rotateNum);
						}
					}
            	}
            }
            //小白花第三种情况
            function step1Case3(rotateNum){
            	if(!isRotating){
            		var cube15 = getCubeByIndex(15,rotateNum);
            		var cube9 = getCubeByIndex(9,rotateNum);
            		var yLineAd = rotateAxisByYLine(YLineAd,rotateNum);
            		var yLine = rotateAxisByYLine(YLine,rotateNum);
            		var zLine = rotateAxisByYLine(ZLine,rotateNum);
            		var xLineAd = rotateAxisByYLine(XLineAd,rotateNum);

            		if(getFaceColorByVector(cube15,yLineAd)==bottomColor){//103、104
						if(getFaceColorByVector(cube9,yLine)!=bottomColor){
							l(rotateNum);
						}else{
							u(rotateNum);
						}
					}
            	}
            }
            //小白花第四种情况
            function step1Case4(rotateNum){
            	if(!isRotating){
            		var cube1 = getCubeByIndex(1,rotateNum);
            		var cube7 = getCubeByIndex(7,rotateNum);
            		var zLine = rotateAxisByYLine(ZLine,rotateNum);
            		var yLine = rotateAxisByYLine(YLine,rotateNum);
            		var xLine = rotateAxisByYLine(XLine,rotateNum);

            		if(getFaceColorByVector(cube1,zLine)==bottomColor||getFaceColorByVector(cube7,zLine)==bottomColor){//105、106
						if(getFaceColorByVector(cube1,yLine)!=bottomColor){
							F(rotateNum);
						}else{
							D(rotateNum)
						}
					}
            	}
            }
            /**
             * 魔方基本公式 U、F、L、D、R、u、f、l、d
             */
            function U(rotateNum,next){
                stepCount++;
            	var cube2 = getCubeByIndex(2,rotateNum);
            	var zLine = rotateAxisByYLine(ZLine,rotateNum);
            	var xLineAd = rotateAxisByYLine(XLineAd,rotateNum);
            	normalize = zLine;
            	rotateMove(cube2,xLineAd,next);
            }
            function u(rotateNum,next){
                stepCount++;
            	var cube2 = getCubeByIndex(2,rotateNum);
            	var xLine = rotateAxisByYLine(XLine,rotateNum);
            	var zLineAd = rotateAxisByYLine(ZLineAd,rotateNum);
            	normalize = xLine;
            	rotateMove(cube2,zLineAd,next);
            }
            function F(rotateNum,next){
                stepCount++;
            	var cube2 = getCubeByIndex(2,rotateNum);
            	var xLine = rotateAxisByYLine(XLine,rotateNum);
            	var yLineAd = rotateAxisByYLine(YLineAd,rotateNum);
            	normalize = xLine;
            	rotateMove(cube2,yLineAd,next);
            }
            function f(rotateNum,next){
                stepCount++;
            	var cube2 = getCubeByIndex(2,rotateNum);
            	var yLine = rotateAxisByYLine(YLine,rotateNum);
            	var xLineAd = rotateAxisByYLine(XLineAd,rotateNum);
            	normalize = yLine;
            	rotateMove(cube2,xLineAd,next)
            }
            function L(rotateNum,next){
                stepCount++;
            	var cube0 = getCubeByIndex(0,rotateNum);
            	var zLine = rotateAxisByYLine(ZLine,rotateNum);
            	var yLineAd = rotateAxisByYLine(YLineAd,rotateNum);
            	normalize = zLine;
            	rotateMove(cube0,yLineAd,next);
            }
            function l(rotateNum,next){
                stepCount++;
            	var cube0 = getCubeByIndex(0,rotateNum);
            	var yLine = rotateAxisByYLine(YLine,rotateNum);
            	var zLineAd = rotateAxisByYLine(ZLineAd,rotateNum);
            	normalize = yLine;
            	rotateMove(cube0,zLineAd,next);
            }
            function D(rotateNum,next){
                stepCount++;
            	var cube8 = getCubeByIndex(8,rotateNum);
            	var xLine = rotateAxisByYLine(XLine,rotateNum);
            	var zLineAd = rotateAxisByYLine(ZLineAd,rotateNum);
            	normalize = xLine;
            	rotateMove(cube8,zLineAd,next);
            }
            function d(rotateNum,next){
                stepCount++;
            	var cube8 = getCubeByIndex(8,rotateNum);
            	var zLine = rotateAxisByYLine(ZLine,rotateNum);
            	var xLineAd = rotateAxisByYLine(XLineAd,rotateNum);
            	normalize = zLine;
            	rotateMove(cube8,xLineAd,next);
            }
            function R(rotateNum,next){
                stepCount++;
            	var cube2 = getCubeByIndex(2,rotateNum);
            	var yLine = rotateAxisByYLine(YLine,rotateNum);
            	var zLineAd = rotateAxisByYLine(ZLineAd,rotateNum);
            	normalize = yLine;
            	rotateMove(cube2,zLineAd,next);
            }
            function r(rotateNum,next){
                stepCount++;
            	var cube2 = getCubeByIndex(2,rotateNum);
            	var zLine = rotateAxisByYLine(ZLine,rotateNum);
            	var yLineAd = rotateAxisByYLine(YLineAd,rotateNum);
            	normalize = zLine;
            	rotateMove(cube2,yLineAd,next);
            }
            function B(rotateNum,next){
                stepCount++;
                var cube20 = getCubeByIndex(20,rotateNum);
                var xLine = rotateAxisByYLine(XLine,rotateNum);
                var yLine = rotateAxisByYLine(YLine,rotateNum);
                normalize = xLine;
                rotateMove(cube20,yLine,next);
            }
            function b(rotateNum,next){
                stepCount++;
                var cube20 = getCubeByIndex(20,rotateNum);
                var xLine = rotateAxisByYLine(XLine,rotateNum);
                var yLineAd = rotateAxisByYLine(YLineAd,rotateNum);
                normalize = xLine;
                rotateMove(cube20,yLineAd,next);
            }
            /**
             * 根据索引获取方块
             * @param  index     索引
             * @param  rotateNum 旋转次数
             */
            function getCubeByIndex(index,rotateNum){
            	var tempIndex = index;
            	var tempRotateNum = rotateNum;
            	while(rotateNum>0){
            		if(parseInt(index/9)==0){
        				if(index%3==0){
        					index += 2;
        				}else if(index%3==1){
        					index += 10;
        				}else if(index%3==2){
        					index += 18;
        				}
        			}else if(index%3==2){
        				if(parseInt(index/9)==0){
        					index += 18;
        				}else if(parseInt(index/9)==1){
        					index += 8;
        				}else if(parseInt(index/9)==2){
        					index -= 2;
        				}
        			}else if(parseInt(index/9)==2){
        				if(index%3==2){
        					index -= 2;
        				}else if(index%3==1){
        					index -= 10;
        				}else if(index%3==0){
        					index -= 18;
        				}
        			}else if(index%3==0){
        				if(parseInt(index/9)==2){
        					index -= 18;
        				}else if(parseInt(index/9)==1){
        					index -= 8;
        				}else if(parseInt(index/9)==0){
        					index += 2;
        				}
        			}
    				rotateNum --;
            	}
            	// if(tempIndex!=index){
            	// 	console.log('num:'+tempRotateNum+' '+tempIndex+' >> '+index);
            	// }
            	var cube; 
				for(var i=0;i<cubes.length;i++){
					if(cubes[i].cubeIndex == index+minCubeIndex){
						cube = cubes[i];
					}
				}
				return cube;
            }
            //根据Y轴旋转向量
            function rotateAxisByYLine(vector,rotateNum){
            	while(rotateNum>0){
					if(vector.angleTo(XLine)==0){
	            		vector = ZLineAd.clone();
	            	}else if(vector.angleTo(ZLineAd)==0){
	            		vector = XLineAd.clone();
	            	}else if(vector.angleTo(XLineAd)==0){
	            		vector = ZLine.clone();
	            	}else if(vector.angleTo(ZLine)==0){
	            		vector = XLine.clone();
	            	}
	            	rotateNum--
            	}
            	return vector;
            }
            //根据颜色序号获取初始化时其对面颜色序号
            function getOppositeColor(no){
            	if(no%2==0||no==0){
            		return no+1;
            	}else{
            		return no-1;
            	}
            }
            //获取法向量和已知向量方向相同的面的颜色序号
            function getFaceColorByVector(cube,vector){
            	var materials = cube.material.materials;
            	var faces = cube.geometry.faces;
            	var normalMatrix = cube.normalMatrix;
            	
            	/**
            	 * 转换视角时摄像机位置发生了变动，模型开始上表面的法向量是世界坐标系的Y轴，现在依然是世界坐标系的Y轴；
            	 * 但是小方块面的法向量乘以其法向量矩阵得到的是视图坐标系中的向量；
            	 * 世界坐标系转换成视图坐标系需要乘以视图矩阵的逆反矩阵。
            	 */
            	var viewMatrix = new THREE.Matrix4();
            	viewMatrix.lookAt(camera.position,viewCenter,camera.up);
		        viewMatrix.getInverse(viewMatrix);
            	var tempVector = vector.clone();
        		tempVector.applyMatrix4(viewMatrix);
        		var angles = [];

            	for(var i=0;i<faces.length;i++){
            		var tempNormal = faces[i].normal.clone();
            		tempNormal.applyMatrix3(normalMatrix);
            		/**
            		 * 按道理这里应该判断两向量夹角是否等于0，但是因为存在精度问题；
            		 * 有可能得到的角度很接近0，但却不等于0，另外不确定到底保留几位小数合适；
            		 * 因此使用判断最小值的方式。
            		 */
            		angles.push(tempNormal.angleTo(tempVector));
            	}
            	var minNo = min(angles).no;
            	return faces[minNo].materialIndex;
            	//document.body.appendChild(materials[faces[minNo].materialIndex].map.image);
    		 	//$frame.style.display = 'none';
            }

            window.requestAnimFrame = (function() {//如果有变化则可能还需要requestAnimationFrame刷新
                return window.requestAnimationFrame ||
                       window.mozRequestAnimationFrame ||
                       window.webkitRequestAnimationFrame ||
                       window.msRequestAnimationFrame ||
                       window.webkitRequestAnimationFrame;
            })();

            //根据页面宽度和高度创建渲染器，并添加容器中
            var $frame = document.getElementById('canvas-frame');
            function initThree() {
                width = window.innerWidth;
                height = window.innerHeight;
                renderer = new THREE.WebGLRenderer({
                    antialias : true
                });
                renderer.setSize(width, height);
                renderer.setClearColor(0xFFFFFF, 1.0);
                $frame.appendChild(renderer.domElement);
            }

            //创建相机，并设置正方向和中心点
            var camera;
            var controller;//视角控制器
            var viewCenter = new THREE.Vector3( 0, 0, 0 );
            function initCamera() {
                camera = new THREE.PerspectiveCamera(45, width / height, 1, 1000);
                camera.position.x = 0;
                camera.position.y = 0;
                camera.position.z = 600;
                camera.up.x = 0;//正方向
                camera.up.y = 1;
                camera.up.z = 0;
                camera.lookAt(viewCenter);
            }

            //创建场景，后续元素需要加入到场景中才会显示出来
            var scene;
            function initScene() {
                scene = new THREE.Scene();
            }

            //创建光线
            var light;
            function initLight() {
            	light = new THREE.AmbientLight(0xfefefe);
				scene.add(light);
            }

            /**
             * 魔方
             * x、y、z 魔方正面左上角坐标
             * num 魔方单位方向上数量
             * len 魔方单位正方体宽高
             * colors 魔方六面体颜色
             */
            function SimpleCube(x,y,z,num,len,colors){
                var cubes = [];
                for(var i=0;i<num;i++){
                    for(var j=0;j<num*num;j++){
                        var cubegeo = new THREE.BoxGeometry(len,len,len);
                        var materials = [];
                        var myFaces = [];
                        //一个小正方体有六个面，每个面使用相同材质的纹理，但是颜色不一样
                        myFaces.push(faces(colors[0]));
                        myFaces.push(faces(colors[1]));
                        myFaces.push(faces(colors[2]));
                        myFaces.push(faces(colors[3]));
                        myFaces.push(faces(colors[4]));
                        myFaces.push(faces(colors[5]));
                        for (var k = 0; k < 6; k++) {
                            var texture = new THREE.Texture(myFaces[k]);
                            texture.needsUpdate = true;
                            materials.push(new THREE.MeshLambertMaterial({
                                map: texture
                            }));
                        }
                        var cubemat = new THREE.MeshFaceMaterial(materials);
                        var cube = new THREE.Mesh( cubegeo, cubemat );
                        //假设整个魔方的中心在坐标系原点，推出每个小正方体的中心
                        cube.position.x = (x+len/2)+(j%3)*len;
                        cube.position.y = (y-len/2)-parseInt(j/3)*len;
                        cube.position.z = (z-len/2)-i*len;
                        cube.matrixWorldNeedsUpdate = true;

                        cubes.push(cube)
                    }
                }
                return cubes;
            }

            //生成canvas素材
            function faces(rgbaColor) {
                var canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 256;
                var context = canvas.getContext('2d');
                if (context) {
                	//画一个宽高都是256的黑色正方形
                	canvas.setAttribute('color',rgbaColor);
                    context.fillStyle = 'rgba(0,0,0,1)';
                    context.fillRect(0, 0, 256, 256);
                    //在内部用某颜色的16px宽的线再画一个宽高为224的圆角正方形并用改颜色填充
                    context.rect(16, 16, 224, 224);
                    context.lineJoin = 'round';
                    context.lineWidth = 16;
                    context.fillStyle = rgbaColor;
                    context.strokeStyle = rgbaColor;
                    context.stroke();
                    context.fill();
                } else {
                    alert('您的浏览器不支持Canvas无法预览.\n');
                }
                return canvas;
            }

            //创建展示场景所需的各种元素
            var cubes
            function initObject() {
            	//生成魔方小正方体
            	cubes = SimpleCube(CubeParams.x,CubeParams.y,CubeParams.z,CubeParams.num,CubeParams.len,CubeParams.colors);
            	var ids = [];   
            	for(var i=0;i<cubes.length;i++){
            		var item = cubes[i];
            		/**
                     * 由于筛选运动元素时是根据物体的id规律来的，但是滚动之后位置发生了变化；
                     * 再根据初始规律筛选会出问题，而且id是只读变量；
                     * 所以这里给每个物体设置一个额外变量cubeIndex，每次滚动之后更新根据初始状态更新该cubeIndex；
                     * 让该变量一直保持初始规律即可。
                     */
                    initStatus.push({
                        x:item.position.x,
                        y:item.position.y,
                        z:item.position.z,
                        cubeIndex:item.id
                    });
                    item.cubeIndex = item.id;
                    ids.push(item.id);
                    scene.add(cubes[i]);//并依次加入到场景中
            	}
                minCubeIndex = min(ids).value;

            	//透明正方体
                var cubegeo = new THREE.BoxGeometry(150,150,150);
                var hex = 0x000000;
                for ( var i = 0; i < cubegeo.faces.length; i += 2 ) {
                    cubegeo.faces[ i ].color.setHex( hex );
                    cubegeo.faces[ i + 1 ].color.setHex( hex );
                }
                var cubemat = new THREE.MeshBasicMaterial({vertexColors: THREE.FaceColors,opacity: 0, transparent: true});
                var cube = new THREE.Mesh( cubegeo, cubemat );
                cube.cubeType = 'coverCube';
                scene.add( cube );
            }

            //渲染
            function render(){
                renderer.clear();
                renderer.render(scene, camera);
                window.requestAnimFrame(render);
            }

            //开始
            function threeStart() {
                initThree();
                initCamera();
                initScene();
                initLight();
                initObject();
                render();
                //监听鼠标事件
                renderer.domElement.addEventListener('mousedown', startCube, false);
                renderer.domElement.addEventListener('mousemove', moveCube, false );
                renderer.domElement.addEventListener('mouseup', stopCube,false);
                //监听触摸事件
                renderer.domElement.addEventListener('touchstart', startCube, false);
                renderer.domElement.addEventListener('touchmove', moveCube, false);
                renderer.domElement.addEventListener('touchend', stopCube, false);
                //视角控制
                controller = new THREE.OrbitControls(camera, renderer.domElement);
                controller.target = viewCenter;//设置控制点

                //自动还原一
                var $autoResetV1 = document.querySelector('#autoResetV1');
                $autoResetV1.addEventListener('click',function(){
                	autoResetV1(cubes)
                },false);

                //随机旋转
                var $randomRotate = document.querySelector('#randomRotate');
                $randomRotate.addEventListener('click',function(){
                	randomRotate();
                },false);
            }

            //魔方操作结束
            function stopCube(){
                intersect = null;
                startPoint = null
            }

            //绕着世界坐标系的某个轴旋转
            function rotateAroundWorldY(obj,rad){
                var x0 = obj.position.x;
                var z0 = obj.position.z;
                /**
                 * 因为物体本身的坐标系是随着物体的变化而变化的，
                 * 所以如果使用rotateZ、rotateY、rotateX等方法，
                 * 多次调用后就会出问题，先改为Quaternion实现。
                 */
                var q = new THREE.Quaternion(); 
                q.setFromAxisAngle( new THREE.Vector3( 0, 1, 0 ), rad );
                obj.quaternion.premultiply( q );
                //obj.rotateY(rad);
                obj.position.x = Math.cos(rad)*x0+Math.sin(rad)*z0;
                obj.position.z = Math.cos(rad)*z0-Math.sin(rad)*x0;
            }
            function rotateAroundWorldZ(obj,rad){
                var x0 = obj.position.x;
                var y0 = obj.position.y;
                var q = new THREE.Quaternion(); 
                q.setFromAxisAngle( new THREE.Vector3( 0, 0, 1 ), rad );
                obj.quaternion.premultiply( q );
                //obj.rotateZ(rad);
                obj.position.x = Math.cos(rad)*x0-Math.sin(rad)*y0;
                obj.position.y = Math.cos(rad)*y0+Math.sin(rad)*x0;
            }
            function rotateAroundWorldX(obj,rad){
                var y0 = obj.position.y;
                var z0 = obj.position.z;
                var q = new THREE.Quaternion(); 
                q.setFromAxisAngle( new THREE.Vector3( 1, 0, 0 ), rad );
                obj.quaternion.premultiply( q );
                //obj.rotateX(rad);
                obj.position.y = Math.cos(rad)*y0-Math.sin(rad)*z0;
                obj.position.z = Math.cos(rad)*z0+Math.sin(rad)*y0;
            }

            //滑动操作魔方
            function moveCube(event){
                getIntersects(event);
                if(intersect){
                    if(!isRotating&&startPoint){//魔方没有进行转动且满足进行转动的条件
                        movePoint = intersect.point;
                        if(!movePoint.equals(startPoint)){//和起始点不一样则意味着可以得到转动向量了
                            var sub = movePoint.sub(startPoint);//计算转动向量
                            rotateMove(intersect.object,sub);
                        }
                    }
                }
                event.preventDefault();
            }

            //某方块在某个方向转动
            function rotateMove(target,vector,next){
            	isRotating = true;//转动标识置为true
            	var direction = getDirection(vector);//获得方向
            	var elements = getBoxs(target,direction);
            	var startTime = new Date().getTime();
                window.requestAnimFrame(function(timestamp){
                    rotateAnimation(elements,direction,timestamp,0,null,next);
                });
            }

            /**
             * 旋转动画
             */
            function rotateAnimation(elements,direction,currentstamp,startstamp,laststamp,next){
                var totalTime = 100;//转动的总运动时间
                if(startstamp===0){
                    startstamp = currentstamp;
                    laststamp = currentstamp;
                }
                if(currentstamp-startstamp>=totalTime){
                    currentstamp = startstamp+totalTime;
                    isRotating = false;
                    startPoint = null;
                    updateCubeIndex(elements);
                }
                switch(direction){
                    //绕z轴顺时针
                    case 0.1:
                    case 1.2:
                    case 2.4:
                    case 3.3:
                        for(var i=0;i<elements.length;i++){
                            rotateAroundWorldZ(elements[i],-90*Math.PI/180*(currentstamp-laststamp)/totalTime);
                        }
                        break;
                    //绕z轴逆时针
                    case 0.2:
                    case 1.1:
                    case 2.3:
                    case 3.4:
                        for(var i=0;i<elements.length;i++){
                            rotateAroundWorldZ(elements[i],90*Math.PI/180*(currentstamp-laststamp)/totalTime);
                        }
                        break;
                    //绕y轴顺时针
                    case 0.4:
                    case 1.3:
                    case 4.3:
                    case 5.4:
                        for(var i=0;i<elements.length;i++){
                            rotateAroundWorldY(elements[i],-90*Math.PI/180*(currentstamp-laststamp)/totalTime);
                        }
                        break;
                    //绕y轴逆时针
                    case 1.4:
                    case 0.3:
                    case 4.4:
                    case 5.3:
                        for(var i=0;i<elements.length;i++){
                            rotateAroundWorldY(elements[i],90*Math.PI/180*(currentstamp-laststamp)/totalTime);
                        }
                        break;
                    //绕x轴顺时针
                    case 2.2:
                    case 3.1:
                    case 4.1:
                    case 5.2:
                        for(var i=0;i<elements.length;i++){
                            rotateAroundWorldX(elements[i],90*Math.PI/180*(currentstamp-laststamp)/totalTime);
                        }
                        break;
                    //绕x轴逆时针
                    case 2.1:
                    case 3.2:
                    case 4.2:
                    case 5.1:
                        for(var i=0;i<elements.length;i++){
                            rotateAroundWorldX(elements[i],-90*Math.PI/180*(currentstamp-laststamp)/totalTime);
                        }
                        break;
                    default:
                        break;
                }
                if(currentstamp-startstamp<totalTime){
                	window.requestAnimFrame(function(timestamp){
                        rotateAnimation(elements,direction,timestamp,startstamp,currentstamp,next);
                    });
                }else{
                	if(next){
            			next();
            		}else{
            			if(isAutoReset){
	            			switch(currentStep){
	                			case 1:
	                				step1();
	                				break;
	            				case 2:
	                				step2();
	                				break;
	                			case 3:
	                				step3();
	                				break;
	                			case 4:
	                				step4();
	                				break;
	                            case 5:
	                                step5();
	                                break;
	                            case 6:
	                                step6();
	                                break;
	                            case 7:
	                                step7();
	                                break;
	                            case 8:
	                                step8();
	                                break;
	                			default:
	                				break;
	                		}
	                	}
            		}
                }
            }

            //更新位置索引
            function updateCubeIndex(elements){
                for(var i=0;i<elements.length;i++){
                    var temp1 = elements[i];
                    for(var j=0;j<initStatus.length;j++){
                        var temp2 = initStatus[j];
                        if( Math.abs(temp1.position.x - temp2.x)<=CubeParams.len/2 && 
                            Math.abs(temp1.position.y - temp2.y)<=CubeParams.len/2 && 
                            Math.abs(temp1.position.z - temp2.z)<=CubeParams.len/2 ){
                            temp1.cubeIndex = temp2.cubeIndex;
                            temp1.skipNext = false;
                            break;
                        }
                    }
                }
            }

            //根据方向获得运动元素
            function getBoxs(target,direction){
                var targetId = target.cubeIndex;
                targetId = targetId-minCubeIndex;
                var numI = parseInt(targetId/9);
                var numJ = targetId%9;
                var boxs = [];
                //根据绘制时的规律判断 no = i*9+j
                switch(direction){
                    //绕z轴
                    case 0.1:
                    case 0.2:
                    case 1.1:
                    case 1.2:
                    case 2.3:
                    case 2.4:
                    case 3.3:
                    case 3.4:
                        for(var i=0;i<cubes.length;i++){
                            var tempId = cubes[i].cubeIndex-minCubeIndex;
                            if(numI===parseInt(tempId/9)){
                                boxs.push(cubes[i]);
                            }
                        }
                        break;
                    //绕y轴
                    case 0.3:
                    case 0.4:
                    case 1.3:
                    case 1.4:
                    case 4.3:
                    case 4.4:
                    case 5.3:
                    case 5.4:
                        for(var i=0;i<cubes.length;i++){
                            var tempId = cubes[i].cubeIndex-minCubeIndex;
                            if(parseInt(numJ/3)===parseInt(tempId%9/3)){
                                boxs.push(cubes[i]);
                            }
                        }
                        break;
                    //绕x轴
                    case 2.1:
                    case 2.2:
                    case 3.1:
                    case 3.2:
                    case 4.1:
                    case 4.2:
                    case 5.1:
                    case 5.2:
                        for(var i=0;i<cubes.length;i++){
                            var tempId = cubes[i].cubeIndex-minCubeIndex;
                            if(tempId%9%3===numJ%3){
                                boxs.push(cubes[i]);
                            }
                        }
                        break;
                    default:
                        break;
                }
                return boxs;
            }

            //获得旋转方向
            function getDirection(vector3){
                var direction;
                //判断差向量和x、y、z轴的夹角
                var xAngle = vector3.angleTo(XLine);
                var xAngleAd = vector3.angleTo(XLineAd);
                var yAngle = vector3.angleTo(YLine);
                var yAngleAd = vector3.angleTo(YLineAd);
                var zAngle = vector3.angleTo(ZLine);
                var zAngleAd = vector3.angleTo(ZLineAd);
                var minAngle = min([xAngle,xAngleAd,yAngle,yAngleAd,zAngle,zAngleAd]).value;//最小夹角

                switch(minAngle){
                    case xAngle:
                        direction = 0;//向x轴正方向旋转90度（还要区分是绕z轴还是绕y轴）
                        if(normalize.equals(YLine)){
                            direction = direction+0.1;//绕z轴顺时针
                        }else if(normalize.equals(YLineAd)){
                            direction = direction+0.2;//绕z轴逆时针
                        }else if(normalize.equals(ZLine)){
                            direction = direction+0.3;//绕y轴逆时针
                        }else{
                            direction = direction+0.4;//绕y轴顺时针
                        }
                        break;
                    case xAngleAd:
                        direction = 1;//向x轴反方向旋转90度
                        if(normalize.equals(YLine)){
                            direction = direction+0.1;//绕z轴逆时针
                        }else if(normalize.equals(YLineAd)){
                            direction = direction+0.2;//绕z轴顺时针
                        }else if(normalize.equals(ZLine)){
                            direction = direction+0.3;//绕y轴顺时针
                        }else{
                            direction = direction+0.4;//绕y轴逆时针
                        }
                        break;
                    case yAngle:
                        direction = 2;//向y轴正方向旋转90度
                        if(normalize.equals(ZLine)){
                            direction = direction+0.1;//绕x轴逆时针
                        }else if(normalize.equals(ZLineAd)){
                            direction = direction+0.2;//绕x轴顺时针
                        }else if(normalize.equals(XLine)){
                            direction = direction+0.3;//绕z轴逆时针
                        }else{
                            direction = direction+0.4;//绕z轴顺时针
                        }
                        break;
                    case yAngleAd:
                        direction = 3;//向y轴反方向旋转90度
                        if(normalize.equals(ZLine)){
                            direction = direction+0.1;//绕x轴顺时针
                        }else if(normalize.equals(ZLineAd)){
                            direction = direction+0.2;//绕x轴逆时针
                        }else if(normalize.equals(XLine)){
                            direction = direction+0.3;//绕z轴顺时针
                        }else{
                            direction = direction+0.4;//绕z轴逆时针
                        }
                        break;
                    case zAngle:
                        direction = 4;//向z轴正方向旋转90度
                        if(normalize.equals(YLine)){
                            direction = direction+0.1;//绕x轴顺时针
                        }else if(normalize.equals(YLineAd)){
                            direction = direction+0.2;//绕x轴逆时针
                        }else if(normalize.equals(XLine)){
                            direction = direction+0.3;//绕y轴顺时针
                        }else{
                            direction = direction+0.4;//绕y轴逆时针
                        }
                        break;
                    case zAngleAd:
                        direction = 5;//向z轴反方向旋转90度
                        if(normalize.equals(YLine)){
                            direction = direction+0.1;//绕x轴逆时针
                        }else if(normalize.equals(YLineAd)){
                            direction = direction+0.2;//绕x轴顺时针
                        }else if(normalize.equals(XLine)){
                            direction = direction+0.3;//绕y轴逆时针
                        }else{
                            direction = direction+0.4;//绕y轴顺时针
                        }
                        break;
                    default:
                        break;
                }
                return direction;
            }

            //获取数组中的最小值
            function min(arr){
                var min = arr[0];
                var no = 0;
                for(var i=1;i<arr.length;i++){
                    if(arr[i]<min){
                        min = arr[i];
                        no = i;
                    }
                }
                return {no:no,value:min};
            }

            //是否存在重复值
            function isRepeat(arr){
                arr.sort(function(a,b){
                    if(a<b){
                        return -1;
                    }
                    if(a>b){
                        return 1;
                    }
                    return 0;
                });
                for(var i=0;i<arr.length-1;i++){
                    if(arr[i]==arr[i+1]){
                        return true;
                    }
                }
                return false;
            }

            //开始操作魔方
            function startCube(event){
                getIntersects(event);
                //魔方没有处于转动过程中且存在碰撞物体
                if(!isRotating&&intersect){
                    startPoint = intersect.point;//开始转动，设置起始点
                    controller.enabled = false;//当刚开始的接触点在魔方上时操作为转动魔方，屏蔽控制器转动
                }else{
                    controller.enabled = true;//当刚开始的接触点没有在魔方上或者在魔方上但是魔方正在转动时操作转动控制器
                }
            }

            //获取操作焦点以及该焦点所在平面的法向量
            function getIntersects(event){
            	//触摸事件和鼠标事件获得坐标的方式有点区别
                if(event.touches){
                    var touch = event.touches[0];
                    mouse.x = (touch.clientX / width)*2 - 1;
                    mouse.y = -(touch.clientY / height)*2 + 1;
                }else{
                    mouse.x = (event.clientX / width)*2 - 1;
                    mouse.y = -(event.clientY / height)*2 + 1;
                }
                raycaster.setFromCamera(mouse, camera);
                //Raycaster方式定位选取元素，可能会选取多个，以第一个为准
                var intersects = raycaster.intersectObjects(scene.children);
                if(intersects.length){
                    try{
                        if(intersects[0].object.cubeType==='coverCube'){
                            intersect = intersects[1];
                            normalize = intersects[0].face.normal;
                        }else{
                            intersect = intersects[0];
                            normalize = intersects[1].face.normal;
                        }
                    }catch(err){
                        //nothing
                    }
                }
            }
        </script>
    </body>
</html>